/*
 * Sysconfig.c
 *
 *  Created on: 20-04-2022
 *      Author: Cristobal
 */

#include "Sysconfig.h"

volatile uint32_t msTick = 0;

void Sysconfig(void){
	// M N P
	RCC->PLLCFGR &= ~(RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLM); // MACROS PARA LLENAR CON 1 PERO AL NEGAR PASA A 0 COMO UN CLEAR
	RCC->PLLCFGR |= N_PLL<<6; // COLOCOCAR EL VALOR 84 EN EL REGISTRO PLLCFGR SUMANDO EN LA POSICION 6
	RCC->PLLCFGR |= P_PLL<<16;
	RCC->PLLCFGR |= M_PLL<<0;
	//HSE
	RCC->CR |= RCC_CR_HSEON; //HABILITA EL OSCILADOR HSE CLOCK EXTERNO 8MHz
	while((RCC->CR & RCC_CR_HSERDY) == 0); // VERIFICA QUE EL OSCILADOR HSE ESTE INICIALIZADO

	// PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC_HSE; // LE DECIMOS AL PLL QUE USAREMOS LA FUENTE EXTERNA HSE
	RCC->CR |= RCC_CR_PLLON; //HABILITA PLL
	while((RCC->CR & RCC_CR_PLLRDY) == 0); // VERIFICA QUE EL PLL ESTE INICIALIZADO

	// PREFETCH
	FLASH->ACR &= ~(FLASH_ACR_LATENCY); // DEJA EN CERO EL REGISTRO, ES COMO UN CLEAR
	FLASH->ACR |= FLASH_ACR_PRFTEN; // HABILITA EL PREFETCH
	FLASH->ACR |= FLASH_ACR_LATENCY_2WS; // FIJA LA LATENCIA EN 2 ESTADOS

	// RELOJ DE SISTEMA
	RCC->CFGR &= ~(RCC_CFGR_SW); // LIMPIAR REGISTRO
	RCC->CFGR |= RCC_CFGR_SW_PLL; // USAR COMO RELOJ DE SISTEMA EL PLL O USAR RCC_CFGR_SWS_1
	while((RCC->CFGR & RCC_CFGR_SWS_PLL) == 0); // VERIFICAR ESTADO DEL RELOJ

	// AHB
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1; // SE DIVIVDE EN 1, TAMBIEN SE USA &= ~(RCC_CFGR_HPRE)

	// APB1
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV2; // SE DIVIDE EN 2, TAMBIEN SE USA RCC_CFGR_PPRE1_2

	// APB2
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1; // SE DIVIDE EN 1, TAMBIEN SE USA &= ~(RCC_CFGR_PPRE2)
}

void SysTick_config(uint32_t systick_valor){

	// RESET
	SysTick->CTRL = 0;
	// VALOR A CARGAR CLOCK x TIEMPO
	SysTick->LOAD = systick_valor-1;
	// SETEO PRIORIDAD DE INTERRUPCION
	NVIC_SetPriority(SysTick_IRQn,0);
	// REINICIO VALOR ACTUAL SYSTICK
	SysTick->VAL = 0;
	// FUENTE DE RELOJ = A MICRO
	// GENERA INTERRUPCION CUANDO LLEGA A CERO
	// HABILITAR SYSTICK
	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk);
}
void msIncTick(void){
	msTick++;
}

uint32_t msGetTick(void){
	return msTick;
}

void delay_ms(uint32_t ms){
	uint32_t starTick = msGetTick(); // 5000
	while(msGetTick() - starTick < ms);
}

void SysTick_Handler(void){
	// LIMPIAR BANDERA DE SYSTICK
	// GPIO_Toggle();
	NVIC_ClearPendingIRQ(SysTick_IRQn);
	msIncTick();
}
